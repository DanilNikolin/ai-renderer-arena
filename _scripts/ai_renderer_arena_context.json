{
  "project_name": "ai-renderer-arena",
  "file_tree": "## Структура проекта\n\n```\nai-renderer-arena\n├── .gitignore\n├── README.md\n├── eslint.config.mjs\n├── next-env.d.ts\n├── next.config.ts\n├── package.json\n├── postcss.config.mjs\n├── src\n│   ├── app\n│   │   ├── api\n│   │   │   ├── generate\n│   │   │   │   └── route.ts\n│   │   │   └── refine-prompt\n│   │   │       └── route.ts\n│   │   ├── globals.css\n│   │   ├── layout.tsx\n│   │   └── page.tsx\n│   ├── components\n│   │   ├── ImageWorkspace.tsx\n│   │   ├── ui\n│   │   │   └── FormControls.tsx\n│   │   └── workspace\n│   │       ├── Canvas.tsx\n│   │       └── Sidebar.tsx\n│   ├── hooks\n│   │   └── useImageWorkspace.ts\n│   └── lib\n│       ├── types.ts\n│       └── utils.ts\n├── tailwind.config.ts\n└── tsconfig.json\n```\n\n---\n\n",
  "code_files": [
    {
      "path": ".gitignore",
      "content": "# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n# dependencies\n/node_modules\n/.pnp\n.pnp.*\n.yarn/*\n!.yarn/patches\n!.yarn/plugins\n!.yarn/releases\n!.yarn/versions\n\n# testing\n/coverage\n\n# next.js\n/.next/\n/out/\n\n# production\n/build\n\n# misc\n.DS_Store\n*.pem\n\n# debug\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n.pnpm-debug.log*\n\n# env files (can opt-in for committing if needed)\n.env*\n!.env.example\n\n# vercel\n.vercel\n\n# typescript\n*.tsbuildinfo\nnext-env.d.ts\n"
    },
    {
      "path": "eslint.config.mjs",
      "content": "import { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { FlatCompat } from \"@eslint/eslintrc\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst compat = new FlatCompat({\n  baseDirectory: __dirname,\n});\n\nconst eslintConfig = [\n  ...compat.extends(\"next/core-web-vitals\", \"next/typescript\"),\n  {\n    ignores: [\n      \"node_modules/**\",\n      \".next/**\",\n      \"out/**\",\n      \"build/**\",\n      \"next-env.d.ts\",\n    ],\n  },\n];\n\nexport default eslintConfig;\n"
    },
    {
      "path": "next-env.d.ts",
      "content": "/// <reference types=\"next\" />\n/// <reference types=\"next/image-types/global\" />\n/// <reference path=\"./.next/types/routes.d.ts\" />\n\n// NOTE: This file should not be edited\n// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.\n"
    },
    {
      "path": "next.config.ts",
      "content": "import type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  /* config options here */\n};\n\nexport default nextConfig;\n"
    },
    {
      "path": "package.json",
      "content": "{\n  \"name\": \"ai-renderer-arena\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"eslint\"\n  },\n  \"dependencies\": {\n    \"@fal-ai/client\": \"^1.6.2\",\n    \"next\": \"^15.5.3\",\n    \"openai\": \"^5.20.3\",\n    \"react\": \"^19.1.1\",\n    \"react-dom\": \"^19.1.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/eslintrc\": \"^3\",\n    \"@tailwindcss/postcss\": \"^4\",\n    \"@types/node\": \"^20\",\n    \"@types/react\": \"^19\",\n    \"@types/react-dom\": \"^19\",\n    \"autoprefixer\": \"^10.4.21\",\n    \"eslint\": \"^9\",\n    \"eslint-config-next\": \"15.5.3\",\n    \"postcss\": \"^8.5.6\",\n    \"tailwindcss\": \"^4\",\n    \"typescript\": \"^5\"\n  }\n}\n"
    },
    {
      "path": "postcss.config.mjs",
      "content": "const config = {\n  plugins: [\"@tailwindcss/postcss\"],\n};\n\nexport default config;"
    },
    {
      "path": "README.md",
      "content": "This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).\n\n## Getting Started\n\nFirst, run the development server:\n\n```bash\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n# or\nbun dev\n```\n\nOpen [http://localhost:3000](http://localhost:3000) with your browser to see the result.\n\nYou can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.\n\nThis project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.\n\n## Learn More\n\nTo learn more about Next.js, take a look at the following resources:\n\n- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.\n- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.\n\nYou can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!\n\n## Deploy on Vercel\n\nThe easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.\n\nCheck out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.\n"
    },
    {
      "path": "tailwind.config.ts",
      "content": "import type { Config } from \"tailwindcss\";\n\nconst config: Config = {\n  content: [\n    \"./src/pages/**/*.{js,ts,jsx,tsx,mdx}\",\n    \"./src/components/**/*.{js,ts,jsx,tsx,mdx}\",\n    \"./src/app/**/*.{js,ts,jsx,tsx,mdx}\",\n  ],\n  theme: {\n    extend: {\n      backgroundImage: {\n        \"gradient-radial\": \"radial-gradient(var(--tw-gradient-stops))\",\n        \"gradient-conic\":\n          \"conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))\",\n      },\n      // ✨ Добавим сюда наши кастомные цвета из твоего кода, чтобы все было в одном месте\n      colors: {\n        'gray-850': '#1b2332',\n        'block-muted': '#483853',\n      },\n    },\n  },\n  plugins: [],\n};\nexport default config;"
    },
    {
      "path": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2017\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n"
    },
    {
      "path": "src/app/globals.css",
      "content": "\n/*D:\\Work\\Image test for 3Dims (3 models)\\ai-renderer-arena\\src\\app\\globals.css*/\n@import \"tailwindcss\";\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n:root {\n  --color-block-muted: #4f2d66;\n}\n\nbody {\n  background-color: #111827; /* Немного смягчим фон */\n  color: #d1d5db; /* Сделаем текст чуть менее резким */\n}\n\n/* Эффект свечения для текста */\n.text-glow {\n  text-shadow: 0 0 8px rgba(56, 189, 248, 0.4);\n}\n\n/* Плавные переходы для интерактивных элементов */\nbutton,\ntextarea,\ninput,\nlabel {\n  transition: all 0.2s ease-in-out;\n}\n\n/* Кастомный скроллбар под нашу тему */\n::-webkit-scrollbar {\n  width: 8px;\n}\n::-webkit-scrollbar-track {\n  background: #1f2937;\n}\n::-webkit-scrollbar-thumb {\n  background: #4b5563;\n  border-radius: 4px;\n}\n::-webkit-scrollbar-thumb:hover {\n  background: #6b7280;\n}\n/* Узкий контейнер для всего приложения */\n.container-narrow {\n  max-width: 1100px; /* можешь поставить 960px/1200px если хочешь уже/шире */\n  margin: 0 auto;\n  padding: 16px;\n}\n\n@media (min-width: 768px) {\n  .container-narrow { padding: 24px; }\n}\n@media (min-width: 1024px) {\n  .container-narrow { padding: 32px; }\n}\n\n/* Поддержка чуть более тёмных карточек */\n.bg-gray-850 {\n  background-color: #1b2332; /* мягкий тёмный между 800 и 900 */\n}\n\n"
    },
    {
      "path": "src/app/layout.tsx",
      "content": "//D:\\Work\\Image test for 3Dims (3 models)\\ai-renderer-arena\\src\\app\\layout.tsx\nimport type { Metadata } from \"next\";\nimport { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\", \"cyrillic\"] });\n\nexport const metadata: Metadata = {\n  title: \"AI Renderer Arena\",\n  description: \"Instruction-Based Image Editing Testbed\",\n};\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"ru\">\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n"
    },
    {
      "path": "src/app/page.tsx",
      "content": "//D:\\Work\\Image test for 3Dims (3 models)\\ai-renderer-arena\\src\\app\\page.tsx\nimport ImageWorkspace from \"@/components/ImageWorkspace\";\n\nexport default function HomePage() {\n  return (\n    <main>\n      <div className=\"container-narrow\">\n        <header className=\"mb-6\">\n          <h1 className=\"text-2xl md:text-3xl font-bold text-cyan-400 text-glow\">AI Renderer Arena</h1>\n          <p className=\"text-gray-400 text-sm mt-1\">\n            Instruction-Based Image Editing • аккуратно и без лишнего растягивания\n          </p>\n        </header>\n\n        <ImageWorkspace />\n      </div>\n    </main>\n  );\n}\n"
    },
    {
      "path": "src/app/api/generate/route.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\n// Гарантируем Node runtime\nexport const runtime = \"nodejs\";\nexport const dynamic = \"force-dynamic\";\n\n// ===== Типы и константы =====\ntype ImgExt = \"png\" | \"jpg\" | \"jpeg\" | \"webp\";\n\n// Учитываем оба варианта изображения в теле запроса\ninterface FalRequestBody {\n  prompt: string;\n  image_url?: string;\n  image_urls?: string[];\n  negative_prompt?: string;\n  seed?: number;\n  num_inference_steps?: number;\n  guidance_scale?: number;\n  safety_tolerance?: number;\n  sync_mode?: boolean; // <--- ДОБАВИЛИ\n  image_size?: { width: number, height: number }; // <--- ДОБАВИЛИ\n}\n\n// Папка автосейва (env > дефолт)\nconst SAVE_DIR =\n  process.env.IMAGES_SAVE_PATH ||\n  \"D:\\\\Work\\\\images from Image test for 3Dims (3 models)\";\n\n// Метки для префикса файлов\nconst MODEL_LABELS: Record<string, string> = {\n  qwen: \"qwen\",\n  flux: \"flux\",\n  seedream: \"sdream\",\n  gemini: \"Nano-Banana\",\n};\n\n// ===== Вспомогалки =====\nfunction inferExt(contentType?: string | null, url?: string): ImgExt {\n  if (contentType) {\n    const ct = contentType.toLowerCase();\n    if (ct.includes(\"png\")) return \"png\";\n    if (ct.includes(\"jpeg\")) return \"jpeg\";\n    if (ct.includes(\"jpg\")) return \"jpg\";\n    if (ct.includes(\"webp\")) return \"webp\";\n  }\n  if (url) {\n    const m = url.toLowerCase().match(/\\.(png|jpe?g|webp)(\\?|#|$)/i);\n    if (m) return (m[1].toLowerCase() as ImgExt).replace(\"jpeg\", \"jpeg\") as ImgExt;\n  }\n  return \"png\";\n}\n\nfunction tsForName(d = new Date()) {\n  const yyyy = d.getFullYear();\n  const mm = String(d.getMonth() + 1).padStart(2, \"0\");\n  const dd = String(d.getDate()).padStart(2, \"0\");\n  const hh = String(d.getHours()).padStart(2, \"0\");\n  const mi = String(d.getMinutes()).padStart(2, \"0\");\n  const ss = String(d.getSeconds()).padStart(2, \"0\");\n  return `${yyyy}-${mm}-${dd}__${hh}-${mi}-${ss}`;\n}\n\n\n// Возвращает следующий индекс для файлов с префиксом <label><N>\nasync function getNextLabelIndex(dir: string, label: string): Promise<number> {\n  try {\n    const files = await fs.readdir(dir).catch(() => []);\n    let max = 0;\n    // Ищем ровно в начале имени: label + число (например, \"нано-банано12__...\")\n    const re = new RegExp(`^${label.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \"\\\\$&\")}(\\\\d+)\\\\b`, \"i\");\n    for (const name of files) {\n      const m = name.match(re);\n      if (m) {\n        const n = Number(m[1]);\n        if (!Number.isNaN(n) && n > max) max = n;\n      }\n    }\n    return max + 1;\n  } catch {\n    return 1;\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  const FAL_KEY = process.env.FAL_KEY;\n  if (!FAL_KEY) {\n    return NextResponse.json({ error: \"Ключ API для fal.ai не найден\" }, { status: 500 });\n  }\n\n  try {\n    const formData = await req.formData();\n    const model = (formData.get(\"model\") as string | null)?.toLowerCase() || null;\n    const prompt = formData.get(\"prompt\") as string | null;\n    const negativePrompt = formData.get(\"negative_prompt\") as string | null;\n    const imageFile = formData.get(\"image\") as File | null;\n    const settingsStr = formData.get(\"settings\") as string | null;\n\n    if (!model || !prompt || !imageFile) {\n      return NextResponse.json({ error: \"Отсутствуют обязательные поля\" }, { status: 400 });\n    }\n\n    // Подготовка входного изображения как data URL\n    const imageBuffer = Buffer.from(await imageFile.arrayBuffer());\n    const imageUrl = `data:${imageFile.type};base64,${imageBuffer.toString(\"base64\")}`;\n\n    // Парсим настройки\n    const settings = settingsStr ? JSON.parse(settingsStr) : {};\n\n    // Базовое тело запроса\n    const body: FalRequestBody = { prompt };\n    if (negativePrompt) body.negative_prompt = negativePrompt;\n\n    // Маршрут и особые поля под конкретную модель\n    let endpointUrl: string;\n    switch (model) {\n      case \"qwen\":\n        endpointUrl = \"https://fal.run/fal-ai/qwen-image-edit\";\n        body.image_url = imageUrl;\n        if (settings.guidance_scale != null) body.guidance_scale = settings.guidance_scale;\n        if (settings.num_inference_steps != null) body.num_inference_steps = settings.num_inference_steps;\n        if (settings.seed != null) body.seed = settings.seed;\n        break;\n\n      case \"flux\":\n        endpointUrl = \"https://fal.run/fal-ai/flux-pro/kontext\";\n        body.image_url = imageUrl;\n        if (settings.guidance_scale != null) body.guidance_scale = settings.guidance_scale;\n        if (settings.safety_tolerance != null) body.safety_tolerance = settings.safety_tolerance;\n        if (settings.seed != null) body.seed = settings.seed;\n        break;\n\n      case \"gemini\": // Nano Banana edit\n        endpointUrl = \"https://fal.run/fal-ai/nano-banana/edit\";\n        body.image_urls = [imageUrl];\n        if (settings.seed != null) body.seed = settings.seed;\n        break;\n\n         case \"seedream\":\n        endpointUrl = \"https://fal.run/fal-ai/bytedance/seedream/v4/edit\";\n        body.image_urls = [imageUrl];\n        body.sync_mode = true; // Важно для получения результата сразу\n\n        if (settings.seed != null) {\n          body.seed = settings.seed;\n        }\n        if (settings.width != null && settings.height != null) {\n          body.image_size = { width: settings.width, height: settings.height };\n        }\n        break;\n\n      default:\n        return NextResponse.json({ error: `Модель '${model}' не поддерживается` }, { status: 400 });\n    } \n    // Вызов FAL\n    const response = await fetch(endpointUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Key ${FAL_KEY}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"API Error Response:\", errorText);\n      return NextResponse.json({ error: `Ошибка API: ${errorText}` }, { status: response.status });\n    }\n\n    const data = await response.json();\n\n    // Унификация ответа: ищем URL итоговой картинки\n    const finalImageUrl: string | undefined =\n      data.images?.[0]?.url || data.image?.url || data.output?.[0]?.url;\n\n    if (!finalImageUrl) {\n      console.error(\"API did not return an image URL. Response:\", data);\n      return NextResponse.json({ error: \"API не вернуло изображение\" }, { status: 500 });\n    }\n\n    // Скачиваем итоговое изображение\n    const imgResp = await fetch(finalImageUrl);\n    if (!imgResp.ok) {\n      const errText = await imgResp.text().catch(() => \"\");\n      return NextResponse.json(\n        { error: `Не удалось скачать изображение: ${imgResp.status} ${errText}` },\n        { status: 502 }\n      );\n    }\n\n    const ct = imgResp.headers.get(\"content-type\");\n    const ext = inferExt(ct, finalImageUrl);\n    const buf = Buffer.from(await imgResp.arrayBuffer());\n\n    // Префикс с меткой модели и авто-индексом: \"<label><N>__...\"\n    const label = MODEL_LABELS[model] ?? model;\n    await fs.mkdir(SAVE_DIR, { recursive: true });\n    const labelIndex = await getNextLabelIndex(SAVE_DIR, label);\n\n    // Хвост имени как у тебя раньше\n    const seedPart =\n      typeof settings?.seed === \"number\" && !Number.isNaN(settings.seed)\n        ? `seed-${settings.seed}`\n        : \"seed-auto\";\n\n    // Итоговое имя: \"<label><N>__<timestamp>__<model>__<seedPart>.<ext>\"\n    const fileName = `${label}${labelIndex}__${tsForName()}__${model}__${seedPart}.${ext}`;\n\n    // Пишем файл\n    const filePath = path.join(SAVE_DIR, fileName);\n    await fs.writeFile(filePath, buf);\n\n    // Ответ\n    return NextResponse.json({\n      imageUrl: finalImageUrl,\n      savedPath: filePath,\n      fileName,\n      label,\n      labelIndex,\n    });\n  } catch (e: any) {\n    console.error(\"Server-side error:\", e);\n    return NextResponse.json(\n      { error: e?.message || \"Неизвестная ошибка на сервере\" },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "path": "src/app/api/refine-prompt/route.ts",
      "content": "import { NextResponse } from \"next/server\";\nimport OpenAI from \"openai\";\n\n// Если используешь типизацию сообщений с мультимодальностью:\ntype TextPart = { type: \"text\"; text: string };\ntype ImagePart = { type: \"image_url\"; image_url: { url: string } };\ntype ChatMsg =\n  | { role: \"system\"; content: string }\n  | { role: \"user\"; content: (TextPart | ImagePart)[] }\n  | { role: \"assistant\"; content: string };\n\ntype RefineBody = {\n  prompt?: string;\n  system?: string;               // системка\n  model?: string;                // gpt-5-mini по умолчанию\n  temperature?: number | string;\n  top_p?: number | string;\n  max_completion_tokens?: number | string;\n  image?: string | null;         // data:image/...;base64,xxxx\n};\n\nfunction num(val: unknown): number | undefined {\n  if (val === null || val === undefined) return undefined;\n  if (typeof val === \"number\") return Number.isFinite(val) ? val : undefined;\n  if (typeof val === \"string\") {\n    const t = val.trim();\n    if (/^[+-]?\\d+$/.test(t)) return parseInt(t, 10);\n    if (/^[+-]?\\d+(\\.\\d+)?$/.test(t)) return parseFloat(t);\n  }\n  return undefined;\n}\n\nexport async function POST(req: Request) {\n  try {\n    const apiKey = process.env.OPENAI_API_KEY;\n    if (!apiKey) {\n      return NextResponse.json(\n        { error: \"OPENAI_API_KEY не задан.\" },\n        { status: 500 }\n      );\n    }\n\n    const client = new OpenAI({\n      apiKey,\n      baseURL: process.env.OPENAI_BASE_URL || undefined,\n    });\n\n    // ---- читаем JSON тело ----\n    const body = (await req.json()) as RefineBody;\n\n    const prompt = (body.prompt ?? \"\").trim();\n    const system = (body.system ?? \"\").trim();\n    const model = (body.model && body.model.trim()) || \"gpt-5-mini\";\n    const temperature = num(body.temperature);\n    const top_p = num(body.top_p);\n    const max_completion_tokens = num(body.max_completion_tokens) ?? 200;\n    const image = (body.image ?? \"\").trim() || null;\n\n    if (!prompt) {\n      return NextResponse.json(\n        { error: \"Поле 'prompt' обязательно.\" },\n        { status: 400 }\n      );\n    }\n\n    // ---- собираем мультимодальные messages ----\n    const userParts: (TextPart | ImagePart)[] = [{ type: \"text\", text: prompt }];\n    if (image) {\n      // ожидаем data:URL или https URL\n      userParts.push({ type: \"image_url\", image_url: { url: image } });\n    }\n\n    const messages: ChatMsg[] = [];\n    if (system) messages.push({ role: \"system\", content: system });\n    messages.push({ role: \"user\", content: userParts });\n\n    // ---- вызов Chat Completions под GPT-5 ----\n    const resp = await client.chat.completions.create({\n      model,\n      // @ts-expect-error — SDK принимает мультимодальные части в messages\n      messages,\n      max_completion_tokens,\n      ...(temperature !== undefined ? { temperature } : {}),\n      ...(top_p !== undefined ? { top_p } : {}),\n    });\n\n    const choice = resp.choices?.[0];\n    const finishReason = choice?.finish_reason ?? \"unknown\";\n    const refinedPrompt = choice?.message?.content?.trim() || \"\";\n\n    if (refinedPrompt) {\n      return NextResponse.json({\n        refinedPrompt,\n        finish_reason: finishReason,\n        usage: resp.usage ?? null,\n      });\n    }\n\n    // если пусто — лог и понятная 502\n    console.error(\"OpenAI empty response:\", JSON.stringify(resp, null, 2));\n    return NextResponse.json(\n      { error: `OpenAI не вернула текст. Причина завершения: '${finishReason}'.` },\n      { status: 502 }\n    );\n  } catch (err: any) {\n    console.error(\"refine-prompt error:\", err);\n    return NextResponse.json(\n      { error: err?.message || \"Неизвестная ошибка.\" },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "path": "src/components/ImageWorkspace.tsx",
      "content": "// src/components/ImageWorkspace.tsx\n\"use client\";\n\nimport React from \"react\";\nimport { useImageWorkspace } from \"@/hooks/useImageWorkspace\";\nimport { Sidebar } from \"./workspace/Sidebar\";\nimport { Canvas } from \"./workspace/Canvas\";\n\nexport default function ImageWorkspace() {\n  // Вся сложность спрятана здесь. Мы получаем готовый 'контракт'.\n  const workspaceState = useImageWorkspace();\n\n  return (\n    <div\n      className=\"grid grid-cols-1 xl:grid-cols-[360px_minmax(0,1fr)] gap-6\"\n      onKeyDown={workspaceState.onKeyDown}\n      tabIndex={0}\n    >\n      {/* Передаем весь набор состояний и функций в сайдбар.\n        Ему не нужно знать, откуда они берутся.\n      */}\n      <Sidebar {...workspaceState} />\n\n      {/* Передаем только то, что нужно для отображения.\n      */}\n      <Canvas\n        isLoading={workspaceState.isLoading}\n        resultUrl={workspaceState.resultUrl}\n        sourceUrl={workspaceState.sourceUrl}\n        sourceFile={workspaceState.sourceFile}\n        tab={workspaceState.tab}\n        setTab={workspaceState.setTab}\n        comparePos={workspaceState.comparePos}\n        setComparePos={workspaceState.setComparePos}\n      />\n    </div>\n  );\n}"
    },
    {
      "path": "src/components/ui/FormControls.tsx",
      "content": "// src/components/ui/FormControls.tsx\n\nimport React, { ChangeEvent } from \"react\";\nimport { cx } from \"@/lib/utils\";\n\n/** --- Маленький компонент для заголовков --- */\nexport const Label: React.FC<{\n  title: string;\n  right?: React.ReactNode;\n  className?: string;\n}> = ({ title, right, className }) => (\n  <div className={cx(\"flex items-center justify-between mb-1.5\", className)}>\n    <span className=\"text-xs text-gray-300\">{title}</span>\n    {right}\n  </div>\n);\n\n/** --- Компонент слайдера с заголовком и полем ввода --- */\nexport const Slider: React.FC<{\n  label: string;\n  value: number;\n  min: number;\n  max: number;\n  step: number;\n  onChange: (e: ChangeEvent<HTMLInputElement>) => void;\n  info?: string;\n  name: string;\n}> = ({ label, value, min, max, step, onChange, info, name }) => (\n  <label className=\"block space-y-1\">\n    <Label\n      title={label}\n      right={\n        <input\n          type=\"number\"\n          value={value}\n          onChange={onChange}\n          min={min}\n          max={max}\n          step={step}\n          name={name}\n          className=\"w-20 bg-gray-900 border border-gray-700 rounded p-1.5 text-xs text-center\"\n        />\n      }\n    />\n    <input\n      type=\"range\"\n      value={value}\n      min={min}\n      max={max}\n      step={step}\n      onChange={onChange}\n      name={name}\n      className=\"w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-cyan-500\"\n    />\n    {info && <p className=\"text-[10px] text-gray-500\">{info}</p>}\n  </label>\n);"
    },
    {
      "path": "src/components/workspace/Canvas.tsx",
      "content": "// src/components/workspace/Canvas.tsx\n\nimport React from \"react\";\nimport { cx } from \"@/lib/utils\";\n\n// Пропсы для управления состоянием и отображением\ninterface CanvasProps {\n  isLoading: boolean;\n  resultUrl: string | null;\n  sourceUrl: string | null;\n  sourceFile: File | null;\n  tab: \"source\" | \"result\" | \"compare\";\n  setTab: (tab: \"source\" | \"result\" | \"compare\") => void;\n  comparePos: number;\n  setComparePos: (pos: number) => void;\n}\n\nexport const Canvas: React.FC<CanvasProps> = ({\n  isLoading,\n  resultUrl,\n  sourceUrl,\n  sourceFile,\n  tab,\n  setTab,\n  comparePos,\n  setComparePos,\n}) => {\n  // Инкапсулируем логику скачивания прямо здесь\n  const handleDownloadSource = () => {\n    if (!sourceUrl || !sourceFile) return;\n    const link = document.createElement(\"a\");\n    link.href = sourceUrl;\n    link.download = sourceFile.name || \"source.png\";\n    link.click();\n  };\n\n  const handleDownloadResult = () => {\n    if (!resultUrl) return;\n    const link = document.createElement(\"a\");\n    link.href = resultUrl;\n    link.download = \"result.png\";\n    link.click();\n  };\n\n  return (\n    <section className=\"space-y-4\">\n      {/* top bar */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm text-gray-400\">\n          {isLoading\n            ? \"Обработка…\"\n            : resultUrl\n            ? \"Готово\"\n            : \"Ожидает запуска\"}\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <div className=\"bg-gray-900 border border-gray-800 rounded-lg p-1 flex\">\n            {([\"source\", \"result\", \"compare\"] as const).map((t) => (\n              <button\n                key={t}\n                onClick={() => setTab(t)}\n                className={cx(\n                  \"px-3 py-1.5 text-xs rounded-md\",\n                  tab === t\n                    ? \"bg-gray-800 text-gray-100\"\n                    : \"text-gray-400 hover:text-gray-200\"\n                )}\n              >\n                {t === \"source\"\n                  ? \"Исходник\"\n                  : t === \"result\"\n                  ? \"Результат\"\n                  : \"Сравнить\"}\n              </button>\n            ))}\n          </div>\n\n          <button\n            onClick={handleDownloadSource}\n            disabled={!sourceUrl}\n            className=\"text-xs px-2.5 py-1.5 rounded border border-gray-800 text-gray-300 hover:bg-gray-800 disabled:opacity-50\"\n          >\n            Скачать исходник\n          </button>\n\n          <button\n            onClick={handleDownloadResult}\n            disabled={!resultUrl}\n            className=\"text-xs px-2.5 py-1.5 rounded border border-gray-800 text-gray-300 hover:bg-gray-800 disabled:opacity-50\"\n          >\n            Скачать результат\n          </button>\n        </div>\n      </div>\n\n      {/* canvases */}\n      <div className=\"bg-gray-850 border border-gray-800 rounded-xl overflow-hidden\">\n        <div className=\"px-3 py-2 border-b border-gray-800 text-xs text-gray-400\">\n          {tab === \"source\"\n            ? \"Исходное изображение\"\n            : tab === \"result\"\n            ? \"Результат\"\n            : \"Сравнение (двигай слайдер)\"}\n        </div>\n\n        <div className=\"relative h-[60vh] md:h-[70vh] bg-gray-900\">\n          {/* loading overlay */}\n          {isLoading && (\n            <div\n              className=\"absolute inset-0 bg-gray-800/50 animate-pulse\"\n              aria-label=\"loading\"\n            />\n          )}\n\n          {/* source */}\n          {tab !== \"result\" &&\n            (sourceUrl ? (\n              <img\n                src={sourceUrl}\n                alt=\"Source\"\n                className=\"absolute inset-0 w-full h-full object-contain\"\n              />\n            ) : (\n              <div className=\"absolute inset-0 flex items-center justify-center text-gray-600 text-sm\">\n                Загрузите изображение\n              </div>\n            ))}\n\n          {/* result */}\n          {tab !== \"source\" &&\n            (resultUrl ? (\n              tab === \"compare\" ? (\n                <>\n                  <img\n                    src={resultUrl}\n                    alt=\"Result\"\n                    className=\"absolute inset-0 w-full h-full object-contain\"\n                    style={{ clipPath: `inset(0 ${100 - comparePos}% 0 0)` }}\n                  />\n                  <div\n                    className=\"absolute inset-0 pointer-events-none border-l-2 border-cyan-500\"\n                    style={{ left: `${comparePos}%` }}\n                  />\n                  <input\n                    type=\"range\"\n                    min={0}\n                    max={100}\n                    value={comparePos}\n                    onChange={(e) => setComparePos(Number(e.target.value))}\n                    className=\"absolute bottom-3 left-1/2 -translate-x-1/2 w-[60%] h-2 bg-gray-700 rounded-lg appearance-none accent-cyan-500\"\n                  />\n                </>\n              ) : (\n                <img\n                  src={resultUrl}\n                  alt=\"Result\"\n                  className=\"absolute inset-0 w-full h-full object-contain\"\n                />\n              )\n            ) : (\n              tab !== \"source\" && (\n                <div className=\"absolute inset-0 flex items-center justify-center text-gray-600 text-sm\">\n                  Пока пусто\n                </div>\n              )\n            ))}\n        </div>\n      </div>\n\n      <div className=\"text-[11px] text-gray-500\">\n        Лайфхак: короткий промпт → выбери модель → Ctrl/Cmd+Enter. Вставка из\n        буфера работает.\n      </div>\n    </section>\n  );\n};"
    },
    {
      "path": "src/components/workspace/Sidebar.tsx",
      "content": "// src/components/workspace/Sidebar.tsx\n\nimport React, { ChangeEvent, DragEvent, RefObject } from \"react\";\nimport { cx } from \"@/lib/utils\";\nimport {\n  ACCEPTED_FILE_TYPES,\n  FluxSettings,\n  LlmSettings,\n  MAX_FILE_SIZE_MB,\n  Model,\n  QwenSettings,\n  SeedreamSettings,\n} from \"@/lib/types\";\nimport { Label, Slider } from \"@/components/ui/FormControls\";\n\n// Определяем все пропсы, которые понадобятся этому компоненту\ninterface SidebarProps {\n  imageInfo: { w: number; h: number } | null;\n  sourceFile: File | null;\n  dropRef: RefObject<HTMLLabelElement>;\n  onDrop: (e: DragEvent<HTMLLabelElement>) => void;\n  onFileChange: (e: ChangeEvent<HTMLInputElement>) => void;\n  showRefiner: boolean;\n  setShowRefiner: (value: React.SetStateAction<boolean>) => void;\n  rawPrompt: string;\n  setRawPrompt: (value: string) => void;\n  llmSettings: LlmSettings;\n  handleLlmSettingsChange: (\n    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => void;\n  setLlmSettings: React.Dispatch<React.SetStateAction<LlmSettings>>;\n  sendImageToLlm: boolean;\n  setSendImageToLlm: (value: boolean) => void;\n  onRefinePrompt: () => void;\n  isRefining: boolean;\n  refineError: string | null;\n  prompt: string;\n  setPrompt: (value: string) => void;\n  showNeg: boolean;\n  setShowNeg: (value: React.SetStateAction<boolean>) => void;\n  negativePrompt: string;\n  setNegativePrompt: (value: string) => void;\n  selectedModel: Model;\n  setSelectedModel: (model: Model) => void;\n  seedLock: boolean;\n  setSeedLock: (value: boolean) => void;\n  randomizeSeed: () => void;\n  qwenSettings: QwenSettings;\n  handleQwenChange: (e: ChangeEvent<HTMLInputElement>) => void;\n  fluxSettings: FluxSettings;\n  handleFluxChange: (e: ChangeEvent<HTMLInputElement>) => void;\n  seedreamSettings: SeedreamSettings;\n  handleSeedreamChange: (e: ChangeEvent<HTMLInputElement>) => void;\n  isReadyToGenerate: boolean;\n  isLoading: boolean;\n  onGenerate: () => void;\n  onCancel: () => void;\n  onClear: () => void;\n  error: string | null;\n  jsonContent: string | null;\n  isJsonViewerOpen: boolean;\n  setIsJsonViewerOpen: (value: React.SetStateAction<boolean>) => void;\n  jsonError: string | null;\n  onJsonFileChange: (e: ChangeEvent<HTMLInputElement>) => void;\n}\n\nexport const Sidebar: React.FC<SidebarProps> = ({\n  imageInfo,\n  sourceFile,\n  dropRef,\n  onDrop,\n  onFileChange,\n  showRefiner,\n  setShowRefiner,\n  rawPrompt,\n  setRawPrompt,\n  llmSettings,\n  handleLlmSettingsChange,\n  setLlmSettings,\n  sendImageToLlm,\n  setSendImageToLlm,\n  onRefinePrompt,\n  isRefining,\n  refineError,\n  prompt,\n  setPrompt,\n  showNeg,\n  setShowNeg,\n  negativePrompt,\n  setNegativePrompt,\n  selectedModel,\n  setSelectedModel,\n  seedLock,\n  setSeedLock,\n  randomizeSeed,\n  qwenSettings,\n  handleQwenChange,\n  fluxSettings,\n  handleFluxChange,\n  seedreamSettings,\n  handleSeedreamChange,\n  isReadyToGenerate,\n  isLoading,\n  onGenerate,\n  onCancel,\n  onClear,\n  error,\n    jsonContent,\n    isJsonViewerOpen,\n    setIsJsonViewerOpen,\n    jsonError,\n    onJsonFileChange,\n    }) => {\n  return (\n    <aside className=\"bg-gray-850 border border-gray-800 rounded-xl p-4 lg:p-5 sticky top-6 h-fit\">\n      {/* file */}\n      <div className=\"space-y-2\">\n        <Label\n          title=\"Исходное изображение\"\n          right={\n            imageInfo && (\n              <span className=\"text-[10px] text-gray-500\">\n                {imageInfo.w}×{imageInfo.h}px\n              </span>\n            )\n          }\n        />\n        <label\n          ref={dropRef}\n          htmlFor=\"image-upload\"\n          onDrop={onDrop}\n          onDragOver={(e) => e.preventDefault()}\n          className={cx(\n            \"group border border-dashed rounded-lg p-4 text-center cursor-pointer transition\",\n            \"border-gray-700 hover:border-cyan-500 bg-gray-900/50\"\n          )}\n          title=\"Перетащи файл или кликни. Можно также вставить из буфера Ctrl+V.\"\n        >\n          {sourceFile ? (\n            <div className=\"text-left space-y-1\">\n              <p className=\"text-cyan-400 text-sm font-medium truncate\">\n                {sourceFile.name}\n              </p>\n              <p className=\"text-xs text-gray-500\">\n                {(sourceFile.size / 1024 / 1024).toFixed(2)} MB •{\" \"}\n                {sourceFile.type.replace(\"image/\", \"\").toUpperCase()}\n              </p>\n            </div>\n          ) : (\n            <div className=\"space-y-1\">\n              <p className=\"text-sm text-gray-400\">\n                Перетащи или нажми, чтобы выбрать\n              </p>\n              <p className=\"text-xs text-gray-500\">\n                PNG, JPEG, WebP • до {MAX_FILE_SIZE_MB}MB • Ctrl+V из буфера\n              </p>\n            </div>\n          )}\n          <input\n            id=\"image-upload\"\n            type=\"file\"\n            className=\"hidden\"\n            accept={ACCEPTED_FILE_TYPES.join(\",\")}\n            onChange={onFileChange}\n          />\n        </label>\n      </div>\n\n{/* JSON Viewer */}\n<div className=\"mt-5 space-y-3 bg-gray-900/50 border border-gray-700/50 rounded-lg p-3\">\n  <button\n    type=\"button\"\n    onClick={() => setIsJsonViewerOpen(v => !v)}\n    className=\"w-full text-left text-sm font-medium text-yellow-400\"\n  >\n    {isJsonViewerOpen ? \"▼ Скрыть JSON Viewer\" : \"► Открыть JSON Viewer\"}\n  </button>\n  {isJsonViewerOpen && (\n    <div className=\"pt-2 space-y-3\">\n      <label \n        htmlFor=\"json-upload\" \n        className=\"block w-full text-center text-xs text-gray-400 border border-dashed border-gray-600 hover:border-yellow-500 rounded-md p-3 cursor-pointer\"\n      >\n        Нажми, чтобы выбрать .json файл\n        <input id=\"json-upload\" type=\"file\" className=\"hidden\" accept=\"application/json\" onChange={onJsonFileChange} />\n      </label>\n      \n      {jsonError && (\n        <p className=\"text-xs text-red-400 bg-red-900/20 p-2 rounded-md\">{jsonError}</p>\n      )}\n\n      {jsonContent && (\n        <pre className=\"bg-gray-950 p-2 rounded-md text-xs text-gray-300 max-h-60 overflow-auto whitespace-pre-wrap\">\n          <code>\n            {jsonContent}\n          </code>\n        </pre>\n      )}\n    </div>\n  )}\n</div>\n\n      {/* prompt refiner */}\n      <div\n  className=\"mt-5 space-y-3 border border-gray-700/50 rounded-lg p-3\" // <-- Убрали отсюда класс bg-[--color-block-muted]\n  style={{ backgroundColor: '#221b25ff' }} // <-- Добавили стиль напрямую\n>\n        <button\n          type=\"button\"\n          onClick={() => setShowRefiner((v) => !v)}\n          className=\"w-full text-left text-sm font-medium text-cyan-400\"\n        >\n            \n          {showRefiner\n            ? \"▼ Скрыть «Промпт-Инженер»\"\n            : \"► Открыть «Промпт-Инженер»\"}\n        </button>\n        {showRefiner && (\n          <div className=\"pt-2 space-y-4\">\n            <div>\n              <Label title=\"1. Сообщение для LLM\" />\n              <textarea\n                rows={3}\n                className=\"w-full bg-gray-900 border border-gray-800 rounded-lg p-3 text-sm placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500\"\n                placeholder=\"Опиши задачу простыми словами (напр.: стены кедр, лавки осина)\"\n                value={rawPrompt}\n                onChange={(e) => setRawPrompt(e.target.value)}\n              />\n            </div>\n\n            <div>\n              <Label title=\"2. Системный промпт для LLM\" />\n              <textarea\n                name=\"systemPrompt\"\n                rows={6}\n                className=\"w-full bg-gray-900 border border-gray-800 rounded-lg p-3 text-xs font-mono placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500\"\n                value={llmSettings.systemPrompt}\n                onChange={handleLlmSettingsChange}\n              />\n            </div>\n\n            <div className=\"grid grid-cols-2 gap-4\">\n              <div>\n                <Label title=\"Модель\" />\n                <div className=\"flex items-center gap-2 rounded-lg bg-gray-950 p-1\">\n                  {([\"gpt-5-mini\", \"gpt-5-nano\"] as const).map((model) => (\n                    <button\n                      key={model}\n                      onClick={() =>\n                        setLlmSettings((p) => ({ ...p, model }))\n                      }\n                      className={`w-full px-2 py-1 text-xs rounded-md transition-colors ${\n                        llmSettings.model === model\n                          ? \"bg-cyan-600 text-white\"\n                          : \"hover:bg-gray-800\"\n                      }`}\n                    >\n                      {model.replace(\"gpt-5-\", \"GPT-5 \")}\n                    </button>\n                  ))}\n                </div>\n              </div>\n              <label className=\"flex flex-col justify-end items-start gap-2 text-xs text-gray-400 cursor-pointer\">\n                <Label title=\"Контекст\" />\n                <div className=\"flex items-center gap-2\">\n                  <input\n                    type=\"checkbox\"\n                    checked={sendImageToLlm}\n                    onChange={(e) => setSendImageToLlm(e.target.checked)}\n                    className=\"accent-cyan-500\"\n                    disabled={!sourceFile}\n                  />\n                  Отправить картинку\n                </div>\n              </label>\n            </div>\n\n            <div className=\"pt-2 border-t border-gray-800 space-y-4\">\n              <Slider\n                label=\"Temperature\"\n                name=\"temperature\"\n                value={llmSettings.temperature}\n                min={0}\n                max={2}\n                step={0.1}\n                onChange={handleLlmSettingsChange}\n              />\n              <Slider\n                label=\"Top P\"\n                name=\"topP\"\n                value={llmSettings.topP}\n                min={0}\n                max={1}\n                step={0.05}\n                onChange={handleLlmSettingsChange}\n              />\n              <Slider\n                label=\"Max Tokens\"\n                name=\"maxCompletionTokens\"\n                value={llmSettings.maxCompletionTokens}\n                min={50}\n                max={1000}\n                step={10}\n                onChange={handleLlmSettingsChange}\n              />\n            </div>\n\n            <div className=\"text-center\">\n              <button\n                onClick={onRefinePrompt}\n                disabled={!rawPrompt.trim() || isRefining}\n                className=\"w-full px-3 py-2 text-sm font-semibold rounded-md bg-cyan-700 hover:bg-cyan-600 text-white disabled:bg-gray-600 disabled:cursor-not-allowed\"\n              >\n                {isRefining ? \"Улучшаю...\" : \"✓ Улучшить и применить промпт\"}\n              </button>\n            </div>\n\n            {refineError && (\n              <p className=\"text-xs text-red-400 bg-red-900/20 p-2 rounded-md\">\n                {refineError}\n              </p>\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* prompt */}\n      <div className=\"mt-5 space-y-2\">\n        <Label\n            title=\"Инструкция для генерации\"\n            right={\n                <span className=\"text-[10px] text-gray-500\">{prompt.trim().length || 0}</span>\n            }\n            />\n        <textarea\n          rows={5}\n          className=\"w-full bg-gray-900 border border-gray-800 rounded-lg p-3 text-sm placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500\"\n          placeholder=\"Напр.: Change the walls to photorealistic Canadian cedar...\"\n          value={prompt}\n          onChange={(e) => setPrompt(e.target.value)}\n        />\n\n        <button\n          type=\"button\"\n          onClick={() => setShowNeg((v) => !v)}\n          className=\"text-xs text-gray-400 hover:text-gray-200 transition underline underline-offset-4\"\n        >\n          {showNeg ? \"Скрыть негативный промпт\" : \"Показать негативный промпт\"}\n        </button>\n\n        {showNeg && (\n          <input\n            type=\"text\"\n            value={negativePrompt}\n            onChange={(e) => setNegativePrompt(e.target.value)}\n            className=\"w-full bg-gray-900 border border-gray-800 rounded-lg p-2 text-xs placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500\"\n            placeholder=\"Что НЕ нужно видеть\"\n          />\n        )}\n      </div>\n\n      {/* model */}\n      <div className=\"mt-5 space-y-2\">\n        <Label title=\"Модель\" />\n        <div className=\"grid grid-cols-4 gap-2\"> \n        {/* ↑↑↑ Теперь тут жестко 4 колонки и небольшой зазор. */}\n          {([\"flux\", \"qwen\", \"seedream\", \"gemini\"] as Model[]).map((m) => {\n            const isActive = selectedModel === m;\n            return (\n              <button\n                key={m}\n                onClick={() => setSelectedModel(m)}\n                className={cx(\n                  \"py-2.5 rounded-lg text-xs font-bold uppercase transition-all duration-200\",\n                  isActive\n                    ? \"bg-green-500 text-white shadow-lg shadow-green-500/30\"\n                    : \"bg-gray-900 border border-gray-700 text-gray-400 hover:bg-gray-800 hover:text-gray-200 hover:border-gray-600\"\n                )}\n              >\n                {m}\n              </button>\n            );\n          })}\n        </div>\n      </div>\n\n      {/* settings */}\n      <div className=\"mt-5 pt-4 border-t border-gray-800 space-y-4\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-sm font-semibold text-gray-200\">Параметры</h3>\n          <div className=\"flex items-center gap-2\">\n            <label className=\"flex items-center gap-1 text-[11px] text-gray-400\">\n              <input\n                type=\"checkbox\"\n                checked={seedLock}\n                onChange={(e) => setSeedLock(e.target.checked)}\n                className=\"accent-cyan-500\"\n              />\n              Фиксировать seed\n            </label>\n            <button\n              type=\"button\"\n              onClick={randomizeSeed}\n              className=\"text-[11px] px-2 py-1 rounded border border-gray-700 text-gray-300 hover:bg-gray-800\"\n              title=\"Случайный seed\"\n            >\n              🎲\n            </button>\n          </div>\n        </div>\n\n        {selectedModel === \"qwen\" && (\n          <>\n            <Slider\n              label=\"Guidance scale\"\n              value={qwenSettings.guidance_scale}\n              min={1}\n              max={10}\n              step={0.1}\n              onChange={handleQwenChange}\n              name=\"guidance_scale\"\n            />\n            <Slider\n              label=\"Inference Steps\"\n              value={qwenSettings.num_inference_steps}\n              min={10}\n              max={60}\n              step={1}\n              onChange={handleQwenChange}\n              name=\"num_inference_steps\"\n            />\n            <Slider\n              label=\"Seed\"\n              value={qwenSettings.seed}\n              min={0}\n              max={2147483647}\n              step={1}\n              onChange={handleQwenChange}\n              name=\"seed\"\n            />\n          </>\n        )}\n\n        {selectedModel === \"flux\" && (\n          <>\n            <Slider\n              label=\"Guidance scale (CFG)\"\n              value={fluxSettings.guidance_scale}\n              min={0}\n              max={10}\n              step={0.1}\n              onChange={handleFluxChange}\n              name=\"guidance_scale\"\n            />\n            <Slider\n              label=\"Safety Tolerance\"\n              value={fluxSettings.safety_tolerance}\n              min={0}\n              max={10}\n              step={0.5}\n              onChange={handleFluxChange}\n              name=\"safety_tolerance\"\n              info=\"Большее — строже safety и потенциальный кроп.\"\n            />\n            <Slider\n              label=\"Seed\"\n              value={fluxSettings.seed}\n              min={0}\n              max={2147483647}\n              step={1}\n              onChange={handleFluxChange}\n              name=\"seed\"\n            />\n          </>\n        )}\n\n       \n\n        {selectedModel === \"seedream\" && (\n          <>\n            <Slider\n              label=\"Seed\"\n              value={seedreamSettings.seed}\n              min={0}\n              max={2147483647}\n              step={1}\n              onChange={handleSeedreamChange}\n              name=\"seed\"\n            />\n             <p className=\"text-xs text-gray-500\">\n              Размер изображения будет взят из исходного файла.\n            </p>\n          </>\n        )}\n\n        {selectedModel === \"gemini\" && (\n          <p className=\"text-xs text-gray-500\">\n            Для Gemini пока нет доп. параметров.\n          </p>\n        )}\n      </div>\n\n      {/* actions */}\n      <div className=\"mt-5 space-y-3\">\n        <button\n          onClick={onGenerate}\n          disabled={!isReadyToGenerate}\n          className={cx(\n            \"w-full inline-flex items-center justify-center gap-2 text-sm font-semibold py-2.5 rounded-lg transition\",\n            isReadyToGenerate\n              ? \"bg-cyan-600 hover:bg-cyan-500 text-white\"\n              : \"bg-gray-700 text-gray-400 cursor-not-allowed\"\n          )}\n          title=\"Ctrl/Cmd+Enter — тоже сработает\"\n        >\n          {isLoading ? \"Генерация...\" : \"Сгенерировать\"}\n        </button>\n\n        <div className=\"flex items-center justify-between\">\n          {isLoading ? (\n            <button\n              onClick={onCancel}\n              className=\"text-xs text-red-400 hover:text-red-300\"\n            >\n              Отменить (Esc)\n            </button>\n          ) : (\n            <button\n              onClick={onClear}\n              className=\"text-xs text-gray-400 hover:text-gray-200\"\n            >\n              Очистить\n            </button>\n          )}\n          {sourceFile && (\n            <span className=\"text-[11px] text-gray-500\">\n              {sourceFile.type.replace(\"image/\", \"\").toUpperCase()}\n            </span>\n          )}\n        </div>\n\n        {error && (\n          <div className=\"text-red-300 text-xs bg-red-900/20 border border-red-800/40 rounded p-2\">\n            <p className=\"font-semibold\">Ошибка</p>\n            <p>{error}</p>\n          </div>\n        )}\n      </div>\n    </aside>\n  );\n};"
    },
    {
      "path": "src/hooks/useImageWorkspace.ts",
      "content": "// src/hooks/useImageWorkspace.ts\n\nimport { useState, useMemo, useEffect, useRef, ChangeEvent, DragEvent, KeyboardEvent } from \"react\";\nimport { FluxSettings, LlmSettings, Model, QwenSettings, SeedreamSettings } from \"@/lib/types\"; // <--- ДОБАВИЛИ SeedreamSettings\nimport { loadPersist, readImageDims, savePersist } from \"@/lib/utils\";\n\nconst initialLlmSettings: LlmSettings = {\n  model: 'gpt-5-mini',\n  systemPrompt: `Ты — «Промт-Инженер», специализированный AI-аналитик. Твоя задача — анализировать сырые входные данные (изображение-чертеж сауны и текстовый список материалов с уже готовыми описаниями) и скомпоновать из них сверхкороткий, убийственно-точный промт для AI-«Художника» (модели типа Qwen-Image-Edit, FLUX).\nТвои руководящие принципы:\nКонтекст: «Художники» (Qwen-Image-Edit и аналоги) держат фокус на первых 4-5 строках. Всё, что дальше — лотерея. Твой итоговый промт должен быть как телеграмма: максимум смысла в минимуме слов.\nФильтрация: На входе — чертеж и список материалов. Черные области на чертеже — это не дизайн, а дыры (окна, двери), которые нужно заполнить. Работай только с видимыми объектами и соответствующими им материалами из списка.\nАЛГОРИТМ СБОРКИ ИТОГОВОГО ПРОМТА ДЛЯ «ХУДОЖНИКА»:\nТвой итоговый промт должен иметь железобетонную структуру. Собирай его строго в этом порядке.\nБЛОК 1: ЗАДАЧА, ГЕОМЕТРИЯ И ЧЕРНЫЕ ДЫРЫ (Высший приоритет)\nИнструкция: Начинай промт с общей задачи, в которую вшито главное ограничение по геометрии. Сразу после, если видишь черные области, добавь команды для их замены. Это самый важный блок.\nШаблоны для генерации:\nПреамбула: You are editing a 3D render to create a masterpiece. Preserve the exact geometry, proportions, and camera FOV.\nОкно: ⚡ A black area on the wall = A photorealistic glass window with a thin wooden frame matching the reference, viewing a Scandinavian forest.\nПанорамная стена: ⚡ A black wall = A panoramic, floor-to-ceiling glass wall with a thin frame matching the reference, viewing a Scandinavian forest. (Используй, если черная область занимает почти всю стену).\nДверь: ⚡ A black doorway = A frameless glass door leading into a bright, minimalist entryway finished with the same wood as the sauna walls.\nБЛОК 2: МАТЕРИАЛЫ («Прямой проброс»)\nИнструкция: Это твоя основная работа. Твоя задача — взять готовую строку с описанием материала из списка клиента и напрямую вставить ее в итоговый промт. Ничего не додумывай. Просто сгруппируй объекты с одинаковым материалом и передай описание как есть.\nФормат генерации: [Объект 1], [Объект 2]: [Описание из списка клиента]. [Объект 3]: [Другое описание из списка].\nПример того, что ты должен сгенерить: Walls, floor: Canadian Cedar polished, with clear texture. Benches: Linden wood.\nБЛОК 3: СВЕТ\nИнструкция: После материалов добавь короткую, ясную команду по свету.\nШаблон для генерации: The lighting must be warm and soft with physically correct shadows; if a window is present, add contrasting cool daylight.\nБЛОК 4: ФИНАЛЬНОЕ КАЧЕСТВО (Приказ)\nИнструкция: В самом конце промта добавь одну мощную команду, которая задает финальную планку качества.\nШаблон для генерации: Elevate the entire image to the quality of an architectural magazine cover, focusing on photorealistic lighting and textures.\nФормат вывода: Итоговый промт для «Художника» не должен превышать 5-7 предложений (примерно 200-250 токенов). Будь безжалостен к каждому слову.\n\n'.`,\n  temperature: 1.0,\n  topP: 1,\n  maxCompletionTokens: 2000,\n};\n\nconst MAX_FILE_SIZE_MB = 10;\nconst ACCEPTED_FILE_TYPES = [\"image/png\", \"image/jpeg\", \"image/webp\"];\n\nexport function useImageWorkspace() {\n  // --- Состояния (State) ---\n  const [sourceFile, setSourceFile] = useState<File | null>(null);\n  const [sourceUrl, setSourceUrl] = useState<string | null>(null);\n  const [resultUrl, setResultUrl] = useState<string | null>(null);\n  const [prompt, setPrompt] = useState(\"\");\n  const [rawPrompt, setRawPrompt] = useState(\"\");\n  const [isRefining, setIsRefining] = useState(false);\n  const [refineError, setRefineError] = useState<string | null>(null);\n  const [sendImageToLlm, setSendImageToLlm] = useState(true);\n  const [showRefiner, setShowRefiner] = useState(false);\n  const [llmSettings, setLlmSettings] = useState<LlmSettings>(initialLlmSettings);\n  const [negativePrompt, setNegativePrompt] = useState(\"blurry, ugly, deformed, text, watermark\");\n  const [showNeg, setShowNeg] = useState(false);\n  const [selectedModel, setSelectedModel] = useState<Model>(\"flux\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [imageInfo, setImageInfo] = useState<{ w: number; h: number } | null>(null);\n  const [tab, setTab] = useState<\"source\" | \"result\" | \"compare\">(\"source\");\n  const [comparePos, setComparePos] = useState(50);\n  const [seedLock, setSeedLock] = useState(false);\n  const [qwenSettings, setQwenSettings] = useState<QwenSettings>({ guidance_scale: 4, num_inference_steps: 30, seed: 0 });\n  const [fluxSettings, setFluxSettings] = useState<FluxSettings>({ guidance_scale: 3.5, safety_tolerance: 2, seed: 0 });\n  const [seedreamSettings, setSeedreamSettings] = useState<SeedreamSettings>({ seed: 0, width: 1024, height: 1024 });\n\n\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const dropRef = useRef<HTMLLabelElement | null>(null);\n\n  const [jsonContent, setJsonContent] = useState<string | null>(null);\n  const [isJsonViewerOpen, setIsJsonViewerOpen] = useState(false);\n  const [jsonError, setJsonError] = useState<string | null>(null);\n  // --- Эффекты (Effects) ---\n\n  // Загрузка состояния из localStorage при первом рендере\n  useEffect(() => {\n    const p = loadPersist();\n    if (!p) return;\n\n    setPrompt(p.prompt ?? \"\");\n    setNegativePrompt(p.negativePrompt ?? \"blurry, ugly, deformed, text, watermark\");\n    setSelectedModel(p.selectedModel ?? \"flux\");\n    setQwenSettings(p.qwenSettings ?? { guidance_scale: 4, num_inference_steps: 30, seed: 0 });\n    setFluxSettings(p.fluxSettings ?? { guidance_scale: 3.5, safety_tolerance: 2, seed: 0 });\n    const loadedSeedream = p.seedreamSettings || {};\n    setSeedreamSettings(prev => ({ ...{ seed: 0, width: 1024, height: 1024 }, ...loadedSeedream }));\n    if (p.llmSettings) setLlmSettings(p.llmSettings);\n    if (typeof p.sendImageToLlm === \"boolean\") setSendImageToLlm(p.sendImageToLlm);\n    if (typeof p.showRefiner === \"boolean\") setShowRefiner(p.showRefiner);\n    if (typeof p.showNeg === \"boolean\") setShowNeg(p.showNeg);\n    if (typeof p.seedLock === \"boolean\") setSeedLock(p.seedLock);\n    if (p.tab) setTab(p.tab);\n    if (typeof p.comparePos === \"number\") setComparePos(p.comparePos);\n  }, []);\n\n  // Сохранение состояния в localStorage при изменении\n  useEffect(() => {\n    savePersist({\n      prompt,\n      negativePrompt,\n      selectedModel,\n      qwenSettings,\n      fluxSettings,\n      seedreamSettings,\n      llmSettings,\n      sendImageToLlm,\n      showRefiner,\n      showNeg,\n      seedLock,\n      tab,\n      comparePos,\n    });\n  }, [\n    prompt,\n    negativePrompt,\n    selectedModel,\n    qwenSettings,\n    fluxSettings,\n    seedreamSettings,\n    llmSettings,\n    sendImageToLlm,\n    showRefiner,\n    showNeg,\n    seedLock,\n    tab,\n    comparePos,\n  ]);\n  \n  // Очистка Object URL при размонтировании\n  useEffect(() => {\n    return () => {\n      if (sourceUrl) URL.revokeObjectURL(sourceUrl);\n    };\n  }, [sourceUrl]);\n  \n  // Обработчик вставки из буфера обмена\n  useEffect(() => {\n    const handler = (ev: ClipboardEvent) => onPaste(ev);\n    window.addEventListener(\"paste\", handler);\n    return () => window.removeEventListener(\"paste\", handler);\n  }, []); // Зависимости пустые, т.к. onPaste определена внутри хука\n\n\n  // --- Обработчики и логика ---\n\n  const handleQwenChange = (e: ChangeEvent<HTMLInputElement>) => {\n    setQwenSettings((p) => ({ ...p, [e.target.name]: Number(e.target.value) }));\n  };\n  const handleFluxChange = (e: ChangeEvent<HTMLInputElement>) => {\n    setFluxSettings((p) => ({ ...p, [e.target.name]: Number(e.target.value) }));\n  };\n  const handleSeedreamChange = (e: ChangeEvent<HTMLInputElement>) => { \n    setSeedreamSettings((p) => ({ ...p, [e.target.name]: Number(e.target.value) }));\n  };\n  \n  const onKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {\n    if (e.key === \"Enter\" && (e.metaKey || e.ctrlKey || (e.target as HTMLElement).tagName !== \"TEXTAREA\")) {\n      e.preventDefault();\n      onGenerate();\n    }\n    if (e.key === \"Escape\") {\n      if (isLoading) onCancel();\n    }\n  };\n\n  const handleLlmSettingsChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    const { name, value, type } = e.target;\n    setLlmSettings(prev => ({\n      ...prev,\n      [name]: type === 'number' ? parseFloat(value) : value,\n    }));\n  };\n  \n  const onRefinePrompt = async () => {\n    if (!rawPrompt.trim()) return;\n    setIsRefining(true);\n    setRefineError(null);\n    abortControllerRef.current = new AbortController();\n\n    function arrayBufferToBase64(buffer: ArrayBuffer): string {\n      let binary = \"\";\n      const bytes = new Uint8Array(buffer);\n      const chunkSize = 0x8000;\n      for (let i = 0; i < bytes.length; i += chunkSize) {\n        const chunk = bytes.subarray(i, i + chunkSize);\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\n      }\n      return btoa(binary);\n    }\n\n    let base64Image: string | undefined = undefined;\n    if (sendImageToLlm && sourceFile) {\n      const buffer = await sourceFile.arrayBuffer();\n      base64Image = `data:${sourceFile.type};base64,${arrayBufferToBase64(buffer)}`;\n    }\n\n    const payload = {\n      prompt: rawPrompt,\n      model: llmSettings.model,\n      system: llmSettings.systemPrompt,\n      temperature: llmSettings.temperature,\n      top_p: llmSettings.topP,\n      max_completion_tokens: llmSettings.maxCompletionTokens,\n      ...(base64Image ? { image: base64Image } : {}),\n    };\n\n    try {\n      const response = await fetch(\"/api/refine-prompt\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(payload),\n        signal: abortControllerRef.current.signal,\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || \"Неизвестная ошибка API\");\n      }\n\n      const data = await response.json();\n      setPrompt(data.refinedPrompt);\n      setShowRefiner(false);\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        if (e.name === \"AbortError\") setRefineError(\"Улучшение отменено.\");\n        else setRefineError(e.message);\n      } else {\n        setRefineError(\"Произошла неизвестная ошибка.\");\n      }\n    } finally {\n      setIsRefining(false);\n    }\n  };\n\n  const isReadyToGenerate = useMemo(() => !!sourceFile && !!prompt.trim() && !isLoading, [sourceFile, prompt, isLoading]);\n\n  const fail = (msg: string) => {\n    setError(msg);\n    setIsLoading(false);\n  };\n\n  const handleFileSelect = async (file: File) => {\n    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) return fail(`Размер файла не должен превышать ${MAX_FILE_SIZE_MB} MB.`);\n    if (!ACCEPTED_FILE_TYPES.includes(file.type)) return fail(\"Неверный тип файла. Используйте PNG, JPEG или WebP.\");\n    \n    setError(null);\n    setResultUrl(null);\n    setTab(\"source\");\n    setSourceFile(file);\n    if (sourceUrl) URL.revokeObjectURL(sourceUrl);\n    const url = URL.createObjectURL(file);\n    setSourceUrl(url);\n    try {\n      const dims = await readImageDims(file);\n      setImageInfo(dims);\n    } catch {\n      setImageInfo(null);\n    }\n  };\n  \n  const handleJsonFile = (file: File) => {\n  const reader = new FileReader();\n  reader.onload = (event) => {\n    try {\n      if (typeof event.target?.result !== 'string') {\n        throw new Error(\"Не удалось прочитать файл.\");\n      }\n      const parsed = JSON.parse(event.target.result);\n      // Форматируем для красивого вывода\n      setJsonContent(JSON.stringify(parsed, null, 2)); \n      setJsonError(null);\n      setIsJsonViewerOpen(true); // Автоматически открываем окно при успехе\n    } catch (e) {\n      setJsonError(\"Ошибка парсинга. Убедись, что это валидный JSON-файл.\");\n      setJsonContent(null);\n    }\n  };\n  reader.onerror = () => {\n    setJsonError(\"Не удалось прочитать файл.\");\n    setJsonContent(null);\n  };\n  reader.readAsText(file);\n};\n\nconst onJsonFileChange = (e: ChangeEvent<HTMLInputElement>) => {\n  const file = e.target.files?.[0];\n  if (file && file.type === \"application/json\") {\n    handleJsonFile(file);\n  } else if (file) {\n    setJsonError(\"Неверный тип файла. Нужен JSON.\");\n  }\n  e.target.value = \"\"; // Сбрасываем инпут\n};\n\n  const onFileChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) handleFileSelect(file);\n    e.target.value = \"\";\n  };\n  \n  const onDrop = (e: DragEvent<HTMLLabelElement>) => {\n    e.preventDefault();\n    const file = e.dataTransfer.files?.[0];\n    if (file) handleFileSelect(file);\n  };\n  \n  const onPaste = async (e: ClipboardEvent) => {\n    const items = e.clipboardData?.items;\n    if (!items) return;\n    for (const it of items) {\n      if (it.type.startsWith(\"image/\")) {\n        const file = it.getAsFile();\n        if (file) {\n          await handleFileSelect(file);\n          break;\n        }\n      }\n    }\n  };\n\n  const onClear = () => {\n    if (sourceUrl) URL.revokeObjectURL(sourceUrl);\n    setSourceFile(null);\n    setSourceUrl(null);\n    setResultUrl(null);\n    setError(null);\n    setPrompt(\"\");\n    setImageInfo(null);\n    setTab(\"source\");\n    setShowRefiner(false);\n    setShowNeg(false);\n    setSendImageToLlm(true);\n    setSeedLock(false);\n    setComparePos(50);\n  };\n\n  const onCancel = () => {\n    abortControllerRef.current?.abort();\n    setIsLoading(false);\n    setError(\"Генерация отменена.\");\n  };\n\n  const randomizeSeed = () => {\n    const seed = Math.floor(Math.random() * 2_147_483_647);\n    if (selectedModel === \"flux\") setFluxSettings((p) => ({ ...p, seed }));\n    if (selectedModel === \"qwen\") setQwenSettings((p) => ({ ...p, seed }));\n    if (selectedModel === \"seedream\") setSeedreamSettings((p) => ({...p, seed }));\n  };\n  \n  const onGenerate = async () => {\n    if (!isReadyToGenerate || !sourceFile) return;\n    setIsLoading(true);\n    setError(null);\n    setResultUrl(null);\n    abortControllerRef.current = new AbortController();\n\n    const formData = new FormData();\n    formData.append(\"image\", sourceFile);\n    formData.append(\"prompt\", prompt);\n    formData.append(\"negative_prompt\", negativePrompt);\n    formData.append(\"model\", selectedModel);\n\n    let settings: QwenSettings | FluxSettings | SeedreamSettings;\n    switch (selectedModel) {\n      case \"qwen\":\n        settings = qwenSettings;\n        break;\n      case \"seedream\":\n        // Перед генерацией подставляем реальные размеры картинки\n        settings = { ...seedreamSettings, width: imageInfo!.w, height: imageInfo!.h };\n        break;\n      case \"flux\":\n      default:\n        settings = fluxSettings;\n        break;\n    }\n    \n    if (!seedLock) {\n      const seed = Math.floor(Math.random() * 2_147_483_647);\n      settings = { ...settings, seed };\n      if (selectedModel === \"qwen\") setQwenSettings(p => ({ ...p, seed }));\n      if (selectedModel === \"seedream\") setSeedreamSettings(p => ({ ...p, seed }));\n      if (selectedModel === \"flux\") setFluxSettings(p => ({ ...p, seed }));\n    }\n\n    formData.append(\"settings\", JSON.stringify(settings));\n\n    try {\n      const response = await fetch(\"/api/generate\", {\n        method: \"POST\",\n        body: formData,\n        signal: abortControllerRef.current.signal,\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || \"Неизвестная ошибка API\");\n      }\n      const data = await response.json();\n      setResultUrl(data.imageUrl);\n      setTab(\"result\");\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        if (e.name === \"AbortError\") setError(\"Генерация отменена.\");\n        else setError(e.message);\n      } else {\n        setError(\"Произошла неизвестная ошибка.\");\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // --- Возвращаем публичный API хука ---\n  return {\n    jsonContent,\n    isJsonViewerOpen,\n    setIsJsonViewerOpen,\n    jsonError,\n    onJsonFileChange,\n    sourceFile,\n    sourceUrl,\n    resultUrl,\n    prompt,\n    setPrompt,\n    rawPrompt,\n    setRawPrompt,\n    isRefining,\n    refineError,\n    sendImageToLlm,\n    setSendImageToLlm,\n    showRefiner,\n    setShowRefiner,\n    llmSettings,\n    setLlmSettings,\n    handleLlmSettingsChange,\n    negativePrompt,\n    setNegativePrompt,\n    showNeg,\n    setShowNeg,\n    selectedModel,\n    setSelectedModel,\n    isLoading,\n    error,\n    imageInfo,\n    tab,\n    setTab,\n    comparePos,\n    setComparePos,\n    seedLock,\n    setSeedLock,\n    qwenSettings,\n    handleQwenChange,\n    fluxSettings,\n    handleFluxChange,\n    seedreamSettings,\n    handleSeedreamChange,\n    dropRef,\n    onKeyDown,\n    onRefinePrompt,\n    isReadyToGenerate,\n    onFileChange,\n    onDrop,\n    onClear,\n    onCancel,\n    randomizeSeed,\n    onGenerate,\n  };\n}"
    },
    {
      "path": "src/lib/types.ts",
      "content": "// src/lib/types.ts\n\nexport type Model = \"gemini\" | \"qwen\" | \"flux\" | \"seedream\";\n\nexport const MAX_FILE_SIZE_MB = 10;\nexport const ACCEPTED_FILE_TYPES = [\"image/png\", \"image/jpeg\", \"image/webp\"];\n\nexport type QwenSettings = { guidance_scale: number; num_inference_steps: number; seed: number };\nexport type FluxSettings = { guidance_scale: number; safety_tolerance: number; seed: number };\nexport type SeedreamSettings = { \n  seed: number; \n  width: number; \n  height: number; \n};\nexport type LlmModel = 'gpt-5-mini' | 'gpt-5-nano';\n\nexport type LlmSettings = {\n  model: LlmModel;\n  systemPrompt: string;\n  temperature: number;\n  topP: number;\n  maxCompletionTokens: number;\n};\n\nexport type PersistState = {\n  prompt: string;\n  negativePrompt: string;\n  selectedModel: Model;\n  qwenSettings: QwenSettings;\n  fluxSettings: FluxSettings;\n  seedreamSettings: SeedreamSettings;\n  llmSettings: LlmSettings;\n  sendImageToLlm: boolean;\n  showRefiner: boolean;\n  showNeg: boolean;\n  seedLock: boolean;\n  tab: \"source\" | \"result\" | \"compare\";\n  comparePos: number;\n};"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "// src/lib/utils.ts\n\nimport { PersistState } from \"./types\";\n\n/**\n * Утилита для склейки CSS-классов.\n */\nexport function cx(...s: (string | false | undefined)[]) {\n  return s.filter(Boolean).join(\" \");\n}\n\n/**\n * Читает размеры изображения из файла.\n */\nexport function readImageDims(file: File): Promise<{ w: number; h: number }> {\n  return new Promise((res, rej) => {\n    const img = new Image();\n    img.onload = () => res({ w: img.naturalWidth, h: img.naturalHeight });\n    img.onerror = rej;\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Загружает состояние из localStorage.\n */\nexport function loadPersist(): PersistState | null {\n  try {\n    const raw = localStorage.getItem(\"image_workspace_v2\");\n    return raw ? JSON.parse(raw) : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Сохраняет состояние в localStorage.\n */\nexport function savePersist(s: PersistState) {\n  try {\n    localStorage.setItem(\"image_workspace_v2\", JSON.stringify(s));\n  } catch {}\n}"
    }
  ]
}